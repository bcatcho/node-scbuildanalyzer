// Generated by CoffeeScript 1.3.3
(function() {
  var SCSim, chai, expect, root, should, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  SCSim = root.SCSim;

  _ = root._;

  chai = root.chai;

  should = chai.should();

  expect = chai.expect;

  describe("SCSim.GameRules", function() {
    var rules;
    rules = null;
    beforeEach(function() {
      var gameData;
      gameData = new SCSim.GameData;
      gameData.addUnit("testUnit", 10, 20, 1, 1);
      return rules = new SCSim.GameRules(gameData);
    });
    return describe("canTrainUnit()", function() {
      it("should be true if enough supply, gas, min, and tech", function() {
        var hud, result;
        hud = {
          minerals: 10,
          gas: 20,
          supply: 0,
          supplyCap: 100
        };
        result = rules.canTrainUnit("testUnit", hud);
        return result.should.be["true"];
      });
      it("should be false if unit min&gas cost more than our bank", function() {
        var hud, result;
        hud = {
          minerals: 9,
          gas: 19
        };
        result = rules.canTrainUnit("testUnit", hud);
        return result.should.be["false"];
      });
      it("should be false if only unit min cost more than our bank", function() {
        var hud, result;
        hud = {
          minerals: 9,
          gas: 100
        };
        result = rules.canTrainUnit("testUnit", hud);
        return result.should.be["false"];
      });
      return it("should be false if unit would excede supply cap", function() {
        var hud, result;
        hud = {
          minerals: 100,
          gas: 100,
          supply: 0,
          supplyCap: 0
        };
        result = rules.canTrainUnit("testUnit", hud);
        return result.should.be["false"];
      });
    });
  });

  SCSim.TestCmdBehavior = (function(_super) {

    __extends(TestCmdBehavior, _super);

    function TestCmdBehavior() {
      this._prop = 0;
      TestCmdBehavior.__super__.constructor.call(this);
    }

    TestCmdBehavior.prototype.prop = function() {
      return this._prop;
    };

    TestCmdBehavior.defaultState({
      messages: {
        prop100: function() {
          return this._prop = 100;
        },
        propTimes2: function() {
          return this._prop *= 2;
        }
      }
    });

    return TestCmdBehavior;

  })(SCSim.Behavior);

  describe("SCSim.Cmd", function() {
    var gameData;
    gameData = new SCSim.GameData;
    gameData.addUnit("testUnit", 0, 0, 2, 0, {
      name: "TestCmdBehavior"
    });
    describe("select()", function() {
      var hud, sim;
      hud = sim = null;
      beforeEach(function() {
        var simRun;
        simRun = new SCSim.SimRun(gameData);
        sim = simRun.sim;
        return hud = simRun.hud;
      });
      return it("constructs a command on selectUnit", function() {
        var cmd, unit;
        unit = sim.makeActor("testUnit");
        hud.addUnit(unit);
        cmd = SCSim.Cmd.selectA("testUnit");
        return cmd.should.be.an.instanceOf(SCSim.Cmd);
      });
    });
    return describe("say()", function() {
      var hud, sim;
      hud = sim = null;
      beforeEach(function() {
        var simRun;
        simRun = new SCSim.SimRun(gameData);
        sim = simRun.sim;
        return hud = simRun.hud;
      });
      it("returns a cmd that modifies a specific type of actor", function() {
        var cmd, unit;
        unit = sim.makeActor("testUnit");
        hud.addUnit(unit);
        cmd = SCSim.Cmd.selectA("testUnit").say("prop100");
        cmd.execute(hud);
        return unit.get("prop").should.equal(100);
      });
      return it("can be chained with other commands", function() {
        var cmd, unit;
        unit = sim.makeActor("testUnit");
        hud.addUnit(unit);
        cmd = SCSim.Cmd.selectA("testUnit").say("prop100").say("propTimes2");
        cmd.execute(hud);
        return unit.get("prop").should.equal(200);
      });
    });
  });

  describe("SCSim.Smarts", function() {
    describe("addToBuild()", function() {
      var smarts;
      smarts = new SCSim.Smarts;
      it("adds first build step at index 0", function() {
        smarts.addToBuild(10, function() {
          return "first";
        });
        return smarts.build[0].iterator().should.equal("first");
      });
      it("adds a later build step after the first", function() {
        smarts.addToBuild(20, function() {
          return "second";
        });
        return smarts.build[1].iterator().should.equal("second");
      });
      it("inserts another build step in sorted order", function() {
        smarts.addToBuild(15, function() {
          return "third";
        });
        return smarts.build[1].iterator().should.equal("third");
      });
      return it("adds a duplicate before it's corresponding match", function() {
        smarts.addToBuild(10, function() {
          return "fourth";
        });
        return smarts.build[0].iterator().should.equal("fourth");
      });
    });
    return describe("decideNextCommand()", function() {
      var buyMinOnly, canBuyMinOnly, gameData, hud, smarts;
      gameData = new SCSim.GameData;
      gameData.addUnit("minOnly", 10, 0, 10, 1);
      gameData.addUnit("gasOnly", 0, 10, 10, 1);
      gameData.addUnit("minAndGas", 10, 10, 10, 1);
      smarts = new SCSim.Smarts(gameData);
      hud = new SCSim.Hud(new SCSim.EventEmitter);
      buyMinOnly = function() {
        return "buyMinOnly";
      };
      canBuyMinOnly = function(hud, rules) {
        return rules.canTrainUnit("minOnly", hud);
      };
      beforeEach(function() {
        var _ref;
        _ref = [0, 0], hud.minerals = _ref[0], hud.gas = _ref[1];
        return smarts = new SCSim.Smarts(gameData);
      });
      it("will buy a unit it can afford and has enough supply for", function() {
        var cmd, time;
        smarts.addToBuild(0, canBuyMinOnly, buyMinOnly);
        hud.minerals = 10;
        hud.supply = 9;
        time = new SCSim.SimTime;
        cmd = smarts.decideNextCommand(hud, time);
        return cmd.should.equal(buyMinOnly);
      });
      it("will not buy something it can't afford", function() {
        var cmd, time;
        smarts.addToBuild(0, canBuyMinOnly, buyMinOnly);
        hud.minerals = 9;
        hud.supply = 9;
        time = new SCSim.SimTime;
        cmd = smarts.decideNextCommand(hud, time);
        return expect(cmd).to.be["null"];
      });
      it("will buy what it can afford at a specified time", function() {
        var cmd, time;
        smarts.addToBuild(20, canBuyMinOnly, buyMinOnly);
        hud.minerals = 10;
        hud.supply = 9;
        time = new SCSim.SimTime(20);
        cmd = smarts.decideNextCommand(hud, time);
        return cmd.should.equal(buyMinOnly);
      });
      return it("won't buy what it can afford _before_ the specified time", function() {
        var cmd, time;
        smarts.addToBuild(20, canBuyMinOnly, buyMinOnly);
        hud.minerals = 10;
        hud.supply = 9;
        time = new SCSim.SimTime(19);
        cmd = smarts.decideNextCommand(hud, time);
        return expect(cmd).to.be["null"];
      });
    });
  });

}).call(this);
