// Generated by CoffeeScript 1.3.1
(function() {
  var SCSim, chai, root, should, _;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  chai = root.chai;

  should = chai.should();

  SCSim = root.SCSim;

  _ = root._;

  _.mixin({
    containsInstanceOf: function(collection, theType) {
      if (_(collection).isObject()) {
        collection = _(collection).values();
      }
      return _(collection).any(function(i) {
        return i instanceof theType;
      });
    }
  });

  SCSim.config.secsPerTick = 1;

  describe('Simulation with one base one worker', function() {
    var base, sim;
    sim = new SCSim.Simulation;
    base = null;
    describe('When told to create a new Simulation::Base', function() {
      base = sim.createActor(SCSim.PrimaryStructure);
      return it('should have a new Simulation::Base subActor', function() {
        return _(sim.subActors).containsInstanceOf(SCSim.PrimaryStructure).should.equal(true);
      });
    });
    describe('When told to start', function() {
      it('should change state to running', function() {
        sim.say('start');
        return sim.stateName.should.equal('running');
      });
      return it('should be at tick count = 0', function() {
        return sim.time.tick.should.equal(0);
      });
    });
    return describe('When the base creates a new worker', function() {
      base.say('buildUnit', 'probe');
      it('should _not yet_ have another subActor that is a Simulation::Worker', function() {
        var filter;
        filter = function(a) {
          return a instanceof SCSim.Harvester;
        };
        return _(sim.subActors).filter(filter).length.should.equal(6);
      });
      it('but after update(build time) it should have a Worker subActor', function() {
        var i, _i;
        for (i = _i = 1; _i <= 100; i = ++_i) {
          sim.update();
        }
        return _(sim.subActors).containsInstanceOf(SCSim.Harvester).should.equal(true);
      });
      return it('the base should receive minerals after some time', function() {
        var i, _i;
        for (i = _i = 1; _i <= 50; i = ++_i) {
          sim.update();
        }
        return base.mineralAmt.should.be.above(0);
      });
    });
  });

  describe('Simulation with one base and two workers', function() {
    var base, sim;
    sim = new SCSim.Simulation;
    sim.logger.fwatchFor('workerStartedMining', function(e) {
      return "" + e.simId;
    });
    sim.say('start');
    base = sim.createActor(SCSim.PrimaryStructure);
    it('should queue up two workers at base', function() {
      base.say('buildUnit', 'probe');
      base.say('buildUnit', 'probe');
      base.say('buildUnit', 'probe');
      sim.update();
      return base.buildQueue.length.should.equal(3);
    });
    it('will make the first worker harvest while the 2nd builds', function() {
      while (base.buildQueue.length > 0) {
        sim.update();
      }
      return base.mineralAmt.should.be.above(0);
    });
    return it('will distribute the workers amongst two mineral patches', function() {
      var i, timeOut, _i;
      timeOut = 200;
      while (!sim.logger.eventOccurs('workerCanceledHarvest', timeOut--)) {
        sim.update();
      }
      for (i = _i = 1; _i <= 40; i = ++_i) {
        sim.update();
      }
      console.log(_(sim.logger.event('workerStartedMining')).unique());
      return _(sim.logger.event('workerStartedMining')).unique().length.should.be.above(1);
    });
  });

}).call(this);
