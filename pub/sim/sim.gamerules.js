// Generated by CoffeeScript 1.3.3
(function() {
  var SCSim, SCe, enumFromList, root, _, _ref, _ref1,
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  if ((_ref1 = SCSim.Enums) == null) {
    SCSim.Enums = {};
  }

  SCe = SCSim.Enums;

  _ = root._;

  enumFromList = function() {
    var list, obj, str, _i, _len;
    list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    obj = {};
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      str = list[_i];
      obj[str] = str;
    }
    return obj;
  };

  SCe.Msg = enumFromList("DepositMinerals", "TrainingComplete");

  SCSim.GameState = (function() {

    function GameState(emitter, rules) {
      this.resources = {
        minerals: 0,
        gas: 0
      };
      this.supply = {
        inUse: 0,
        cap: 0
      };
      this.units = {};
      this.structures = {};
      this.observeEvents(emitter, rules);
    }

    GameState.prototype.observeEvents = function(emitter, rules) {
      var obs,
        _this = this;
      obs = function(eventName, filter, callBack) {
        return emitter.observe(eventName, function(eventObj) {
          return callBack(filter(eventObj));
        });
      };
      return obs(SCe.Msg.DepositMinerals, function(e) {
        return e.args[0];
      }, function(minAmt) {
        return rules.applyCollectResources(_this, minAmt, 0);
      });
    };

    return GameState;

  })();

  SCSim.GameRules = (function() {

    function GameRules(gameData) {
      this.gameData = gameData;
    }

    GameRules.prototype.canTrainUnit = function(gameState, unitName) {
      var unit;
      unit = this.gameData.get(unitName);
      return this.meetsCriteria(unit, gameState, this.canAfford, this.hasEnoughSupply, this.hasTechPath);
    };

    GameRules.prototype.canAfford = function(data, hud) {
      return hud.gas >= data.gas && hud.minerals >= data.min;
    };

    GameRules.prototype.hasEnoughSupply = function(data, hud) {
      return data.supply <= hud.supplyCap - hud.supply;
    };

    GameRules.prototype.hasTechPath = function(data, hud) {
      return true;
    };

    GameRules.prototype.meetsCriteria = function() {
      var criteria, data, hud;
      data = arguments[0], hud = arguments[1], criteria = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      return criteria.reduce((function(acc, c) {
        return acc && c(data, hud);
      }), true);
    };

    GameRules.prototype.applyCollectResources = function(gameState, minerals, gas) {
      gameState.resources.minerals += minerals;
      return gameState.resources.gas += gas;
    };

    GameRules.prototype.applyTrainUnit = function(gameState, unitName) {
      var unit;
      unit = this.gameData.get(unitName);
      gameState.resources.minerals -= unit.min;
      gameState.resources.gas -= unit.gas;
      return gameState.supply.inUse += unit.supply;
    };

    return GameRules;

  })();

  SCSim.GameCmdInterpreter = (function() {

    function GameCmdInterpreter(hud, rules) {
      this.hud = hud;
      this.rules = rules;
      this.testState = {
        resources: {
          minerals: 0,
          gas: 0
        },
        supply: {
          inUse: 0,
          cap: 0
        }
      };
      this.verbToRule = {
        train: "applyTrainUnit"
      };
    }

    GameCmdInterpreter.prototype.execute = function(cmd, hud, rules) {
      return false;
    };

    GameCmdInterpreter.prototype.canExecute = function(gameState, rules, cmd) {
      this.testState.resources.minerals = gameState.resources.minerals;
      this.testState.resources.gas = gameState.resources.gas;
      this.testState.supply.inUse = gameState.supply.inUse;
      this.testState.supply.cap = gameState.supply.cap;
      this.applyRuleForAction(this.testState, rules, cmd.verb, cmd.verbObject);
      if (this.testState.resources.minerals < 0) {
        return false;
      }
      if (this.testState.resources.gas < 0) {
        return false;
      }
      if (this.testState.supply.inUse > this.testState.supply.cap) {
        return false;
      }
      return true;
    };

    GameCmdInterpreter.prototype.applyRuleForAction = function(gameState, rules, verb, verbObject) {
      return rules[this.verbToRule[verb]](gameState, verbObject);
    };

    return GameCmdInterpreter;

  })();

  SCSim.GameCmd = (function() {

    function GameCmd(subject) {
      this.article = "any";
      this.subject = subject;
      this.verb;
      this.verbObject;
      this.and = this;
    }

    GameCmd.select = function(subject) {
      return new this(subject);
    };

    GameCmd.prototype.train = function(name) {
      var _ref2;
      _ref2 = ["train", name], this.verb = _ref2[0], this.verbObject = _ref2[1];
      return this;
    };

    return GameCmd;

  })();

  SCSim.Cmd = (function() {
    var train;

    function Cmd(subject, verbs) {
      this.subject = subject;
      this.verbs = verbs != null ? verbs : [];
    }

    Cmd.selectA = function(name) {
      return new this(function(hud) {
        var _ref2, _ref3;
        return ((_ref2 = hud.structures[name]) != null ? _ref2[0] : void 0) || ((_ref3 = hud.units[name]) != null ? _ref3[0] : void 0);
      });
    };

    Cmd.prototype.and = function() {
      return this;
    };

    Cmd.prototype.say = function(msg, a, b, c, d) {
      this.verbs.push(function(unit) {
        return unit.say(msg, a, b, c, d);
      });
      return this;
    };

    train = {
      structure: function(name) {},
      unit: function(name) {}
    };

    Cmd.prototype.execute = function(hud) {
      var s, v, _i, _len, _ref2, _results;
      s = this.subject(hud);
      _ref2 = this.verbs;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        v = _ref2[_i];
        _results.push(v(s));
      }
      return _results;
    };

    return Cmd;

  })();

}).call(this);
