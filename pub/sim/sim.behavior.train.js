// Generated by CoffeeScript 1.3.3
(function() {
  var SCSim, SCe, root, _, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  if ((_ref1 = SCSim.Enums) == null) {
    SCSim.Enums = {};
  }

  SCe = SCSim.Enums;

  _ = root._;

  SCSim.Trainable = (function(_super) {

    __extends(Trainable, _super);

    function Trainable() {
      this.callbacks = [];
    }

    Trainable.prototype.instantiate = function() {
      Trainable.__super__.instantiate.call(this);
      return this.buildTime = (this.sim.gameData.get(this.actor.actorName)).buildTime;
    };

    Trainable.defaultState({
      update: function() {
        return function() {
          if (this.startTime + this.buildTime <= this.time.sec) {
            return this.go("trained");
          }
        };
      },
      enterState: function() {
        this.blockActor();
        return this.startTime = this.time.sec;
      },
      messages: {
        trainInstantly: function() {
          return this.go("trained");
        },
        addCallback: function(fn) {
          return this.callbacks.push(fn);
        }
      }
    });

    Trainable.state("trained", {
      enterState: function() {
        var callback, _i, _len, _ref2;
        this.unblockActor();
        _ref2 = this.callbacks;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          callback = _ref2[_i];
          callback(this.actor);
        }
        return this.say("trainingComplete", this.actor);
      }
    });

    return Trainable;

  })(SCSim.Behavior);

  SCSim.UnitTrainer = (function(_super) {

    __extends(UnitTrainer, _super);

    function UnitTrainer() {
      this.building;
      this.queued = [];
      UnitTrainer.__super__.constructor.call(this);
    }

    UnitTrainer.prototype.queueLength = function() {
      return this.queued.length;
    };

    UnitTrainer.prototype.updateBuildQueue = function() {
      var _this = this;
      if (this.building === void 0 && this.queued.length > 0) {
        this.building = this.sim.makeActor(this.queued[0]);
        this.building.say("addCallback", (function(unit) {
          return _this.say("trainUnitComplete", unit);
        }));
        return this.queued = this.queued.slice(1);
      }
    };

    UnitTrainer.defaultState({
      messages: {
        trainUnit: function(unitName) {
          this.queued.push(unitName);
          return this.updateBuildQueue();
        },
        trainUnitInstantly: function(unitName) {
          var actor,
            _this = this;
          actor = this.sim.makeActor(unitName);
          actor.say("addCallback", (function(unit) {
            return _this.say("trainUnitComplete", unit);
          }));
          return actor.say("trainInstantly");
        },
        trainUnitComplete: function(unit) {
          this.building = void 0;
          return this.updateBuildQueue();
        }
      }
    });

    return UnitTrainer;

  })(SCSim.Behavior);

  SCSim.StructureBuilder = (function(_super) {

    __extends(StructureBuilder, _super);

    function StructureBuilder() {
      StructureBuilder.__super__.constructor.call(this);
    }

    StructureBuilder.defaultState({
      messages: {
        buildStructure: function(structureName) {
          var actor;
          return actor = this.sim.makeActor(structureName);
        }
      }
    });

    return StructureBuilder;

  })(SCSim.Behavior);

}).call(this);
