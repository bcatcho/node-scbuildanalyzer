// Generated by CoffeeScript 1.3.3
(function() {
  var SCSim, root, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  _ = root._;

  SCSim.Trainable = (function(_super) {

    __extends(Trainable, _super);

    function Trainable() {
      this.callbacks = [];
    }

    Trainable.prototype.instantiate = function() {
      this.buildTime = (this.sim.gameData.get(this.actor.actorName)).buildTime;
      return Trainable.__super__.instantiate.call(this);
    };

    Trainable.defaultState({
      update: function() {
        return function() {
          if (this.startTime + this.buildTime <= this.time.sec) {
            return this.say("complete");
          }
        };
      },
      enterState: function() {
        this.blockActor();
        return this.startTime = this.time.sec;
      },
      messages: {
        trainInstantly: function() {
          return this.say("complete");
        },
        addCallback: function(fn) {
          return this.callbacks.push(fn);
        },
        complete: function() {
          var c, _i, _len, _ref1;
          this.unblockActor();
          _ref1 = this.callbacks;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            c = _ref1[_i];
            c(this.actor);
          }
          return this.go("trained");
        }
      }
    });

    Trainable.state("trained", {
      enterState: function() {
        return this.say("trainingComplete", this.actor);
      }
    });

    return Trainable;

  })(SCSim.Behavior);

  SCSim.Trainer = (function(_super) {

    __extends(Trainer, _super);

    function Trainer() {
      this.building;
      this.queued = [];
      Trainer.__super__.constructor.call(this);
    }

    Trainer.prototype.updateBuildQueue = function() {
      var _this = this;
      if (this.building === void 0 && this.queued.length > 0) {
        this.building = this.sim.makeActor(this.queued[0]);
        this.building.say("addCallback", (function(unit) {
          return _this.say("trainUnitComplete", unit);
        }));
        return this.queued = this.queued.slice(1);
      }
    };

    Trainer.defaultState({
      messages: {
        trainUnit: function(unitName) {
          this.queued.push(unitName);
          return this.updateBuildQueue();
        },
        trainUnitComplete: function(unit) {
          this.building = void 0;
          return this.updateBuildQueue();
        }
      }
    });

    return Trainer;

  })(SCSim.Behavior);

  SCSim.WarpInBuilder = (function(_super) {

    __extends(WarpInBuilder, _super);

    function WarpInBuilder() {}

    WarpInBuilder.defaultState({
      messages: {
        build: function(structureName) {
          return this.sim.say("trainActor", structureName);
        }
      }
    });

    return WarpInBuilder;

  })(SCSim.Behavior);

}).call(this);
