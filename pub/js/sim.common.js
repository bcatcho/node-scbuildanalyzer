// Generated by CoffeeScript 1.3.1
(function() {
  var SCSim, SimActor, SimEventLog, SimTimer, root, _, _ref,
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ = root._;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  SCSim.SimEventLog = SimEventLog = (function() {

    SimEventLog.name = 'SimEventLog';

    function SimEventLog() {
      this.events = {};
      this.eventsToCollect = {};
    }

    SimEventLog.prototype.defaultFormatter = function(e) {
      return e;
    };

    SimEventLog.prototype.event = function(eventName, filter) {
      var _ref1;
      return (_ref1 = this.events[eventName]) != null ? _ref1 : [];
    };

    SimEventLog.prototype.watchFor = function(events) {
      var e, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        e = events[_i];
        this.eventsToCollect[e] = this.defaultFormatter;
        _results.push(this.events[e] = []);
      }
      return _results;
    };

    SimEventLog.prototype.fwatchFor = function(eventName, formatter) {
      var _base, _ref1;
      this.eventsToCollect[eventName] = formatter != null ? formatter : this.defaultFormatter;
      return (_ref1 = (_base = this.events)[eventName]) != null ? _ref1 : _base[eventName] = [];
    };

    SimEventLog.prototype.isTrackingEvent = function(eventName) {
      return this.eventsToCollect[eventName] !== void 0;
    };

    SimEventLog.prototype.log = function(e) {
      var formatter;
      formatter = this.eventsToCollect[e.eventName];
      if (formatter) {
        return this.events[e.eventName].push(formatter(e));
      }
    };

    SimEventLog.prototype.clear = function() {
      this.events = {};
      return this.watchFor(_(this.eventsToCollect).keys());
    };

    SimEventLog.prototype.eventOccurs = function(eventName, timeOut, condition) {
      if (!this.isTrackingEvent(eventName)) {
        this.fwatchFor(eventName);
      }
      if (this.event(eventName).length > 0) {
        if (condition !== void 0) {
          return condition(this.event(eventName)) || timeOut <= 0;
        } else {
          return true;
        }
      } else {
        return timeOut <= 0;
      }
    };

    return SimEventLog;

  })();

  SCSim.SimTimer = SimTimer = (function() {

    SimTimer.name = 'SimTimer';

    function SimTimer() {
      this.tick = 0;
      this.seconds = 0;
    }

    SimTimer.prototype.step = function(steps) {
      if (steps == null) {
        steps = 1;
      }
      this.tick += steps;
      return this.seconds += steps;
    };

    SimTimer.prototype.reset = function() {
      this.tick = 0;
      return this.seconds = 0;
    };

    return SimTimer;

  })();

  SCSim.SimActor = SimActor = (function() {

    SimActor.name = 'SimActor';

    function SimActor(defaultStateName) {
      if (defaultStateName == null) {
        defaultStateName = "default";
      }
      this.currentState;
      this.currentTransitions;
      this.switchStateTo(defaultStateName);
    }

    SimActor.prototype.switchStateTo = function(sn, a, b, c, d) {
      var _ref1;
      this.stateName = sn;
      this.currentState = this["state_" + this.stateName].update.call(this, a, b, c, d);
      this.currentTransitions = this["state_" + this.stateName].messages;
      return (_ref1 = this["state_" + this.stateName].enterState) != null ? _ref1.call(this, a, b, c, d) : void 0;
    };

    SimActor.prototype.say = function(msgName, a, b, c, d) {
      var _ref1, _ref2;
      if ((_ref1 = this.logger) != null) {
        _ref1.log({
          eventName: msgName,
          eventTime: this.time.tick,
          simId: this.simId,
          args: [a, b, c, d]
        });
      }
      return (_ref2 = this.currentTransitions[msgName]) != null ? _ref2.call(this, a, b, c, d) : void 0;
    };

    SimActor.prototype.update = function(t) {
      return this.currentState(t);
    };

    SimActor.state = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.prototype["state_" + args[0]] = args[1];
    };

    SimActor.defaultState = function(obj) {
      return this.prototype["state_default"] = obj;
    };

    SimActor.prototype.isExpired = function(t) {
      return t <= 0;
    };

    SimActor.prototype.sayAfter = function(timeSpan, a, b, c, d) {
      return function(t) {
        if (this.isExpired(timeSpan--)) {
          return this.say(a, b, c, d);
        }
      };
    };

    SimActor.noopUpdate = function() {
      return function() {};
    };

    return SimActor;

  })();

}).call(this);
