// Generated by CoffeeScript 1.3.1
(function() {
  var SCSim, root, _, _ref;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ = root._;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  SCSim.EventLog = (function() {

    EventLog.name = 'EventLog';

    function EventLog() {
      this.events = {};
      this.eventsToCollect = {};
    }

    EventLog.prototype.defaultFormatter = function(e) {
      return e;
    };

    EventLog.prototype.event = function(eventName, filter) {
      var _ref1;
      return (_ref1 = this.events[eventName]) != null ? _ref1 : [];
    };

    EventLog.prototype.watchFor = function(events) {
      var e, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        e = events[_i];
        this.eventsToCollect[e] = this.defaultFormatter;
        _results.push(this.events[e] = []);
      }
      return _results;
    };

    EventLog.prototype.fwatchFor = function(eventName, formatter) {
      var _base, _ref1;
      this.eventsToCollect[eventName] = formatter != null ? formatter : this.defaultFormatter;
      return (_ref1 = (_base = this.events)[eventName]) != null ? _ref1 : _base[eventName] = [];
    };

    EventLog.prototype.isTrackingEvent = function(eventName) {
      return this.eventsToCollect[eventName] !== void 0;
    };

    EventLog.prototype.log = function(e) {
      var formatter;
      formatter = this.eventsToCollect[e.name];
      if (formatter) {
        return this.events[e.name].push(formatter(e));
      }
    };

    EventLog.prototype.clear = function() {
      this.events = {};
      return this.watchFor(_(this.eventsToCollect).keys());
    };

    EventLog.prototype.eventOccurs = function(eventName, timeOut, condition) {
      if (!this.isTrackingEvent(eventName)) {
        this.fwatchFor(eventName);
      }
      if (this.event(eventName).length > 0) {
        if (condition !== void 0) {
          return condition(this.event(eventName)) || timeOut <= 0;
        } else {
          return true;
        }
      } else {
        return timeOut <= 0;
      }
    };

    return EventLog;

  })();

  SCSim.SimTime = (function() {

    SimTime.name = 'SimTime';

    function SimTime() {
      this.tick = 0;
      this.sec = 0;
      this.secPerTick = SCSim.config.secsPerTick;
    }

    SimTime.prototype.step = function(steps) {
      if (steps == null) {
        steps = 1;
      }
      this.tick += steps;
      return this.sec += steps * this.secPerTick;
    };

    SimTime.prototype.reset = function() {
      this.tick = 0;
      return this.sec = 0;
    };

    return SimTime;

  })();

  SCSim.Behavior = (function() {

    Behavior.name = 'Behavior';

    function Behavior(defaultStateName) {
      if (defaultStateName == null) {
        defaultStateName = "default";
      }
      this.currentState;
      this.messages;
      this.switchStateTo(defaultStateName);
    }

    Behavior.prototype.update = function(t) {
      return this.currentState(t);
    };

    Behavior.prototype.switchStateTo = function(sn, a, b, c, d) {
      var _ref1;
      this.stateName = sn;
      this.currentState = this.states[this.stateName].update.call(this, a, b, c, d);
      this.messages = this.states[this.stateName].messages;
      return (_ref1 = this.states[this.stateName].enterState) != null ? _ref1.call(this, a, b, c, d) : void 0;
    };

    Behavior.prototype.say = function(msgName, a, b, c, d) {
      var _ref1, _ref2;
      if ((_ref1 = this.logger) != null) {
        _ref1.log({
          name: msgName,
          time: this.time,
          simId: this.simId,
          args: [a, b, c, d]
        });
      }
      return (_ref2 = this.messages[msgName]) != null ? _ref2.call(this, a, b, c, d) : void 0;
    };

    Behavior.state = function(name, stateObj) {
      if (!this.prototype.states) {
        this.prototype.states = {};
      }
      return this.prototype.states[name] = stateObj;
    };

    Behavior.defaultState = function(stateObj) {
      if (!this.prototype.states) {
        this.prototype.states = {};
      }
      return this.prototype.states["default"] = stateObj;
    };

    Behavior.prototype.isExpired = function(t) {
      return t <= 0;
    };

    Behavior.prototype.sayAfter = function(timeSpan, a, b, c, d) {
      var endTime;
      endTime = this.time.sec + timeSpan;
      return function(t) {
        if (this.isExpired(endTime - this.time.sec)) {
          return this.say(a, b, c, d);
        }
      };
    };

    Behavior.noopUpdate = function() {
      return function() {};
    };

    return Behavior;

  })();

  SCSim.Actor = (function() {

    Actor.name = 'Actor';

    function Actor(behaviors, a, b, c, d) {
      var bName, behavior, _i, _len;
      this.behaviors = {};
      for (_i = 0, _len = behaviors.length; _i < _len; _i++) {
        bName = behaviors[_i];
        behavior = new SCSim[bName](a, b, c, d);
        behavior.actor = this;
        this.behaviors[bName] = behavior;
      }
    }

    Actor.prototype.instantiate = function() {
      var behavior, n, _ref1, _results;
      _ref1 = this.behaviors;
      _results = [];
      for (n in _ref1) {
        behavior = _ref1[n];
        behavior.simId = this.simId;
        behavior.logger = this.logger;
        behavior.time = this.time;
        behavior.sim = this.sim;
        _results.push(typeof behavior.instantiate === "function" ? behavior.instantiate() : void 0);
      }
      return _results;
    };

    Actor.prototype.update = function(t) {
      var b, n, _ref1, _results;
      _ref1 = this.behaviors;
      _results = [];
      for (n in _ref1) {
        b = _ref1[n];
        _results.push(b.update(t));
      }
      return _results;
    };

    Actor.prototype.say = function(msgName, a, b, c, d) {
      var behavior, n, _ref1, _ref2, _ref3, _results;
      if ((_ref1 = this.logger) != null) {
        _ref1.log({
          name: msgName,
          time: this.time,
          simId: this.simId,
          args: [a, b, c, d]
        });
      }
      _ref2 = this.behaviors;
      _results = [];
      for (n in _ref2) {
        behavior = _ref2[n];
        _results.push((_ref3 = behavior.messages[msgName]) != null ? _ref3.call(behavior, a, b, c, d) : void 0);
      }
      return _results;
    };

    Actor.prototype.get = function(name, a, b, c, d) {
      var behavior, n, _ref1;
      _ref1 = this.behaviors;
      for (n in _ref1) {
        behavior = _ref1[n];
        if (behavior[name] !== void 0) {
          return behavior[name].call(behavior, a, b, c, d);
        }
      }
      return console.warn("failed to get " + prop);
    };

    return Actor;

  })();

}).call(this);
