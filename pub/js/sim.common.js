// Generated by CoffeeScript 1.3.1
(function() {
  var SCSim, root, _, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ = root._;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  SCSim.EventLog = (function() {

    EventLog.name = 'EventLog';

    function EventLog() {
      this.events = {};
      this.eventsToCollect = {};
    }

    EventLog.prototype.defaultFormatter = function(e) {
      return e;
    };

    EventLog.prototype.event = function(eventName, filter) {
      var _ref1;
      return (_ref1 = this.events[eventName]) != null ? _ref1 : [];
    };

    EventLog.prototype.watchFor = function(events) {
      var e, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = events.length; _i < _len; _i++) {
        e = events[_i];
        this.eventsToCollect[e] = this.defaultFormatter;
        _results.push(this.events[e] = []);
      }
      return _results;
    };

    EventLog.prototype.fwatchFor = function(eventName, formatter) {
      var _base, _ref1;
      this.eventsToCollect[eventName] = formatter != null ? formatter : this.defaultFormatter;
      return (_ref1 = (_base = this.events)[eventName]) != null ? _ref1 : _base[eventName] = [];
    };

    EventLog.prototype.isTrackingEvent = function(eventName) {
      return this.eventsToCollect[eventName] !== void 0;
    };

    EventLog.prototype.log = function(e) {
      var formatter;
      formatter = this.eventsToCollect[e.name];
      if (formatter) {
        return this.events[e.name].push(formatter(e));
      }
    };

    EventLog.prototype.clear = function() {
      this.events = {};
      return this.watchFor(_(this.eventsToCollect).keys());
    };

    EventLog.prototype.eventOccurs = function(eventName, timeOut, condition) {
      if (!this.isTrackingEvent(eventName)) {
        this.fwatchFor(eventName);
      }
      if (this.event(eventName).length > 0) {
        if (condition !== void 0) {
          return condition(this.event(eventName)) || timeOut <= 0;
        } else {
          return true;
        }
      } else {
        return timeOut <= 0;
      }
    };

    return EventLog;

  })();

  SCSim.SimTime = (function() {

    SimTime.name = 'SimTime';

    function SimTime() {
      this.tick = 0;
      this.sec = 0;
      this.secPerTick = SCSim.config.secsPerTick;
    }

    SimTime.prototype.step = function(steps) {
      if (steps == null) {
        steps = 1;
      }
      this.tick += steps;
      return this.sec += steps * this.secPerTick;
    };

    SimTime.prototype.reset = function() {
      this.tick = 0;
      return this.sec = 0;
    };

    return SimTime;

  })();

  SCSim.Actor = (function() {

    Actor.name = 'Actor';

    function Actor(defaultStateName) {
      if (defaultStateName == null) {
        defaultStateName = "default";
      }
      this.currentState;
      this.currentTransitions;
      this.switchStateTo(defaultStateName);
    }

    Actor.prototype.switchStateTo = function(sn, a, b, c, d) {
      var _ref1;
      this.stateName = sn;
      this.currentState = this["state_" + this.stateName].update.call(this, a, b, c, d);
      this.currentTransitions = this["state_" + this.stateName].messages;
      return (_ref1 = this["state_" + this.stateName].enterState) != null ? _ref1.call(this, a, b, c, d) : void 0;
    };

    Actor.prototype.say = function(msgName, a, b, c, d) {
      var _ref1, _ref2;
      if ((_ref1 = this.logger) != null) {
        _ref1.log({
          name: msgName,
          time: this.time,
          simId: this.simId,
          args: [a, b, c, d]
        });
      }
      return (_ref2 = this.currentTransitions[msgName]) != null ? _ref2.call(this, a, b, c, d) : void 0;
    };

    Actor.prototype.update = function(t) {
      return this.currentState(t);
    };

    Actor.state = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.prototype["state_" + args[0]] = args[1];
    };

    Actor.defaultState = function(obj) {
      return this.prototype["state_default"] = obj;
    };

    Actor.prototype.isExpired = function(t) {
      return t <= 0;
    };

    Actor.prototype.sayAfter = function(timeSpan, a, b, c, d) {
      var endTime;
      endTime = this.time.sec + timeSpan;
      return function(t) {
        if (this.isExpired(endTime - this.time.sec)) {
          return this.say(a, b, c, d);
        }
      };
    };

    Actor.noopUpdate = function() {
      return function() {};
    };

    return Actor;

  })();

  SCSim.Behavior = (function() {

    Behavior.name = 'Behavior';

    function Behavior(defaultStateName) {
      if (defaultStateName == null) {
        defaultStateName = "default";
      }
      this.currentState;
      this.currentTransitions;
      this.switchStateTo(defaultStateName);
    }

    Behavior.prototype.switchStateTo = function(sn, a, b, c, d) {
      var _ref1;
      this.stateName = sn;
      this.currentState = this["state_" + this.stateName].update.call(this, a, b, c, d);
      this.currentTransitions = this["state_" + this.stateName].messages;
      return (_ref1 = this["state_" + this.stateName].enterState) != null ? _ref1.call(this, a, b, c, d) : void 0;
    };

    Behavior.prototype.say = function(msgName, a, b, c, d) {
      var _ref1, _ref2;
      if ((_ref1 = this.logger) != null) {
        _ref1.log({
          name: msgName,
          time: this.time,
          simId: this.simId,
          args: [a, b, c, d]
        });
      }
      return (_ref2 = this.currentTransitions[msgName]) != null ? _ref2.call(this, a, b, c, d) : void 0;
    };

    Behavior.state = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.prototype["state_" + args[0]] = args[1];
    };

    Behavior.defaultState = function(obj) {
      return this.prototype["state_default"] = obj;
    };

    Behavior.prototype.isExpired = function(t) {
      return t <= 0;
    };

    Behavior.prototype.sayAfter = function(timeSpan, a, b, c, d) {
      var endTime;
      endTime = this.time.sec + timeSpan;
      return function(t) {
        if (this.isExpired(endTime - this.time.sec)) {
          return this.say(a, b, c, d);
        }
      };
    };

    return Behavior;

  })();

  SCSim.Actor2 = (function(_super) {

    __extends(Actor2, _super);

    Actor2.name = 'Actor2';

    function Actor2() {
      var b, behaviors;
      behaviors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.behaviors = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = behaviors.length; _i < _len; _i++) {
          b = behaviors[_i];
          _results.push(new b(this));
        }
        return _results;
      }).call(this);
      Actor2.__super__.constructor.call(this);
    }

    Actor2.prototype.update = function(t) {
      var b, _i, _len, _ref1, _results;
      _ref1 = this.behaviors;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        b = _ref1[_i];
        _results.push(b.update(t));
      }
      return _results;
    };

    Actor2.prototype.say = function(msgName, a, b, c, d) {
      var _i, _len, _ref1, _ref2, _ref3, _results;
      if ((_ref1 = this.logger) != null) {
        _ref1.log({
          name: msgName,
          time: this.time,
          simId: this.simId,
          args: [a, b, c, d]
        });
      }
      _ref2 = this.behaviors;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        b = _ref2[_i];
        _results.push((_ref3 = b.messages[msgName]) != null ? _ref3.call(b, a, b, c, d) : void 0);
      }
      return _results;
    };

    return Actor2;

  })(SCSim.Actor);

}).call(this);
