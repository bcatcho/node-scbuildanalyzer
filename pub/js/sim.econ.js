// Generated by CoffeeScript 1.3.1
(function() {
  var SCSim, root, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ = root._;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  SCSim.Simulation = (function(_super) {

    __extends(Simulation, _super);

    Simulation.name = 'Simulation';

    function Simulation(emitter) {
      this.subActors = {};
      this.emitter = emitter;
      this.time = new SCSim.SimTime;
      Simulation.__super__.constructor.call(this);
    }

    Simulation.prototype.makeActor = function(name, a, b, c, d) {
      var actorData, instance;
      actorData = SCSim.data.units[name] || SCSim.data.buildings[name] || SCSim.data.neutral[name];
      instance = new SCSim.Actor(actorData.behaviors, a, b, c, d);
      instance.sim = this;
      instance.simId = _.uniqueId();
      instance.emitter = this.emitter;
      instance.time = this.time;
      this.subActors[instance.simId] = instance;
      if (typeof instance.instantiate === "function") {
        instance.instantiate();
      }
      return instance;
    };

    Simulation.prototype.getActor = function(simId) {
      return this.subActors[simId];
    };

    Simulation.defaultState({
      messages: {
        start: function() {
          return this.go("running");
        }
      }
    });

    Simulation.state("running", {
      update: function() {
        return function(t) {
          var actr, _results;
          this.time.step(1);
          _results = [];
          for (actr in this.subActors) {
            _results.push(this.subActors[actr].update(this.time.sec));
          }
          return _results;
        };
      }
    });

    return Simulation;

  })(SCSim.Behavior);

  SCSim.Trainer = (function(_super) {

    __extends(Trainer, _super);

    Trainer.name = 'Trainer';

    function Trainer() {
      this.buildQueue = [];
      Trainer.__super__.constructor.call(this);
    }

    Trainer.prototype.updateBuildQueue = function() {
      var unit;
      if (this.buildQueue.length > 0) {
        unit = this.buildQueue[0];
        if (this.isExpired(unit.buildTime - (this.time.sec - unit.startTime))) {
          return this.say("trainUnitComplete", unit.unitName);
        }
      }
    };

    Trainer.defaultState({
      update: function() {
        return function() {
          return this.updateBuildQueue();
        };
      },
      messages: {
        trainUnit: function(unitName) {
          var u;
          u = SCSim.data.units[unitName];
          return this.buildQueue.push({
            startTime: this.time.sec,
            buildTime: u.buildTime,
            unitName: unitName
          });
        },
        trainUnitComplete: function(unitName) {
          var unit;
          unit = this.sim.makeActor(unitName);
          unit.say("gatherFromResource", this.actor.get("rallyResource"));
          this.buildQueue = this.buildQueue.slice(1);
          if (this.buildQueue.length > 0) {
            return this.buildQueue[0].startTime = this.time.sec;
          }
        }
      }
    });

    return Trainer;

  })(SCSim.Behavior);

  SCSim.PrimaryStructure = (function(_super) {

    __extends(PrimaryStructure, _super);

    PrimaryStructure.name = 'PrimaryStructure';

    function PrimaryStructure() {
      this.mineralAmt = 0;
      this.mins = [];
      this._rallyResource = this.mins[0];
      this.rr = 0;
      PrimaryStructure.__super__.constructor.call(this);
    }

    PrimaryStructure.prototype.rallyResource = function() {
      return this._rallyResource;
    };

    PrimaryStructure.prototype.instantiate = function() {
      var harvester, i, _i, _j, _len, _ref1, _results;
      this.mins = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; _i <= 8; i = ++_i) {
          _results.push(this.sim.makeActor("minPatch", this));
        }
        return _results;
      }).call(this);
      for (i = _i = 1; _i <= 6; i = ++_i) {
        this.harvesters = this.sim.makeActor("probe");
      }
      this._rallyResource = this.mins[0];
      _ref1 = this.harvesters;
      _results = [];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        harvester = _ref1[_j];
        _results.push(harvester.say("gatherFromResource", this._rallyResource));
      }
      return _results;
    };

    PrimaryStructure.prototype.getMostAvailableMinPatch = function() {
      this.mins = _.sortBy(this.mins, function(m) {
        return m.targetedBy;
      });
      return this.mins[0];
    };

    PrimaryStructure.defaultState({
      messages: {
        depositMinerals: function(minAmt) {
          this.mineralAmt += minAmt;
          return this.say("mineralsCollected", this.mineralAmt);
        }
      }
    });

    return PrimaryStructure;

  })(SCSim.Behavior);

  SCSim.MinPatch = (function(_super) {

    __extends(MinPatch, _super);

    MinPatch.name = 'MinPatch';

    function MinPatch(base, startingAmt) {
      if (startingAmt == null) {
        startingAmt = 100;
      }
      this.amt = startingAmt;
      this._base = base;
      this._targetedBy = 0;
      this.harvesters = [];
      this.harvesterMining = null;
      this.harvesterOverlapThreshold = SCSim.config.harvesterOverlapThreshold;
      MinPatch.__super__.constructor.call(this);
    }

    MinPatch.prototype.base = function() {
      return this._base;
    };

    MinPatch.prototype.targetedBy = function() {
      return this._targetedBy;
    };

    MinPatch.prototype.getClosestAvailableResource = function() {
      var m, sortedMins, _i, _len;
      sortedMins = _(this._base.mins).sortBy(function(m) {
        return m.get("targetedBy");
      });
      for (_i = 0, _len = sortedMins.length; _i < _len; _i++) {
        m = sortedMins[_i];
        if (m !== this) {
          return m;
        }
      }
    };

    MinPatch.prototype.isAvailable = function() {
      return this.harvesterMining === null;
    };

    MinPatch.prototype.isAvailableSoon = function(harvester) {
      return this.harvesterMiningTimeDone - this.time.sec < this.harvesterOverlapThreshold;
    };

    MinPatch.defaultState({
      messages: {
        harvesterArrived: function(harvester) {
          return this.harvesters.push(harvester);
        },
        mineralsHarvested: function(amtHarvested) {
          return this.amt -= amtHarvested;
        },
        harvestBegan: function(harvester, timeMiningDone) {
          this.harvesterMiningTimeDone = timeMiningDone;
          return this.harvesterMining = harvester;
        },
        harvestComplete: function(harvester, amtMined) {
          this.harvesterMining = null;
          this.harvesters = _(this.harvesters).rest();
          return this.amt -= amtMined;
        },
        harvestAborted: function(harvester) {
          this.harvesters = _(this.harvesters).without(harvester);
          if (this.harvesterMining === harvester) {
            return this.harvesterMining = null;
          }
        },
        targetedByHarvester: function() {
          return this._targetedBy += 1;
        },
        untargetedByHarvester: function() {
          return this._targetedBy -= 1;
        }
      }
    });

    return MinPatch;

  })(SCSim.Behavior);

  SCSim.Harvester = (function(_super) {

    __extends(Harvester, _super);

    Harvester.name = 'Harvester';

    function Harvester() {
      this.t_toBase = 2;
      this.t_toPatch = 2;
      this.t_mine = 1.5;
      this.targetResource;
      this.collectAmt = 5;
      Harvester.__super__.constructor.call(this, "idle");
    }

    Harvester.state("idle", {
      messages: {
        gatherFromResource: function(resource) {
          this.targetResource = resource;
          this.targetResource.say("targetedByHarvester");
          return this.go("approachResource");
        }
      }
    });

    Harvester.state("approachResource", {
      update: function() {
        return this.sayAfter(this.t_toBase, "resourceReached");
      },
      messages: {
        resourceReached: function() {
          this.targetResource.say("harvesterArrived", this);
          return this.go("waitAtResource");
        }
      }
    });

    Harvester.state("waitAtResource", {
      update: function() {
        return function() {
          if (this.targetResource.get("isAvailable")) {
            return this.go("harvest");
          }
        };
      },
      enterState: function() {
        var nextResource;
        if (this.targetResource.get("isAvailable")) {
          return this.go("harvest");
        } else if (!this.targetResource.get("isAvailableSoon")) {
          nextResource = this.targetResource.get("getClosestAvailableResource");
          if (nextResource) {
            return this.say("changeTargetResource", nextResource);
          }
        }
      },
      messages: {
        changeTargetResource: function(newResource) {
          this.targetResource.say("harvestAborted", this);
          this.targetResource.say("untargetedByHarvester");
          this.targetResource = newResource;
          this.targetResource.say("targetedByHarvester");
          return this.go("approachResource");
        }
      }
    });

    Harvester.state("harvest", {
      update: function() {
        return this.sayAfter(this.t_mine, "harvestComplete");
      },
      enterState: function() {
        return this.targetResource.say("harvestBegan", this, this.time.sec + this.t_mine);
      },
      messages: {
        harvestComplete: function() {
          this.targetResource.say("harvestComplete", this, this.collectAmt);
          return this.go("approachDropOff", this.targetResource.get("base"));
        }
      }
    });

    Harvester.state("approachDropOff", {
      update: function(dropOff) {
        return this.sayAfter(this.t_toBase, "dropOffReached", dropOff);
      },
      messages: {
        dropOffReached: function(dropOff) {
          return this.go("dropOff", dropOff);
        }
      }
    });

    Harvester.state("dropOff", {
      enterState: function(dropOff) {
        dropOff.say("depositMinerals", this.collectAmt);
        return this.say("dropOffComplete", dropOff);
      },
      messages: {
        dropOffComplete: function(dropOff) {
          return this.go("approachResource");
        }
      }
    });

    return Harvester;

  })(SCSim.Behavior);

}).call(this);
