// Generated by CoffeeScript 1.3.1
(function() {
  var SCSim, root, _, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ = root._;

  SCSim = (_ref = root.SCSim) != null ? _ref : {};

  root.SCSim = SCSim;

  SCSim.Simulation = (function(_super) {

    __extends(Simulation, _super);

    Simulation.name = 'Simulation';

    function Simulation() {
      this.subActors = {};
      this.logger = new SCSim.EventLog;
      this.time = new SCSim.SimTime;
      Simulation.__super__.constructor.call(this);
    }

    Simulation.prototype.createActor = function(actr, a, b, c, d) {
      var instance;
      instance = new actr(a, b, c, d);
      instance.sim = this;
      instance.simId = _.uniqueId();
      instance.logger = this.logger;
      instance.time = this.time;
      this.subActors[instance.simId] = instance;
      if (typeof instance.instantiate === "function") {
        instance.instantiate();
      }
      return instance;
    };

    Simulation.prototype.getActor = function(simId) {
      return this.subActors[simId];
    };

    Simulation.defaultState({
      update: Simulation.noopUpdate,
      messages: {
        start: function() {
          return this.switchStateTo('running');
        }
      }
    });

    Simulation.state("running", {
      update: function() {
        return function(t) {
          var actr, _results;
          this.time.step(1);
          _results = [];
          for (actr in this.subActors) {
            _results.push(this.subActors[actr].update(this.time.sec));
          }
          return _results;
        };
      }
    });

    return Simulation;

  })(SCSim.Actor);

  SCSim.Trainer = (function(_super) {

    __extends(Trainer, _super);

    Trainer.name = 'Trainer';

    function Trainer() {
      this.bQueue = [];
      Trainer.__super__.constructor.call(this);
    }

    return Trainer;

  })(SCSim.Actor);

  SCSim.PrimaryStructure = (function(_super) {

    __extends(PrimaryStructure, _super);

    PrimaryStructure.name = 'PrimaryStructure';

    function PrimaryStructure() {
      this.mineralAmt = 0;
      this.mins = [];
      this.rallyResource = this.mins[0];
      this.buildQueue = [];
      PrimaryStructure.__super__.constructor.call(this);
    }

    PrimaryStructure.prototype.instantiate = function() {
      var i, wrkr, _i, _j, _len, _ref1, _results;
      this.mins = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; _i <= 8; i = ++_i) {
          _results.push(this.sim.createActor(SCSim.MinPatch, this));
        }
        return _results;
      }).call(this);
      for (i = _i = 1; _i <= 6; i = ++_i) {
        this.workers = this.sim.createActor(SCSim.Harvester, this);
      }
      this.rallyResource = this.mins[0];
      _ref1 = this.workers;
      _results = [];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        wrkr = _ref1[_j];
        _results.push(wrkr.say('gatherFromMinPatch', this.rallyResource));
      }
      return _results;
    };

    PrimaryStructure.prototype.updateBuildQueue = function() {
      var unit;
      if (this.buildQueue.length > 0) {
        unit = this.buildQueue[0];
        if (this.isExpired(unit.buildTime - (this.time.sec - unit.startTime))) {
          return this.say('doneBuildUnit', unit.unitName);
        }
      }
    };

    PrimaryStructure.prototype.getMostAvailableMinPatch = function() {
      this.mins = _.sortBy(this.mins, function(m) {
        return m.targetedBy;
      });
      return this.mins[0];
    };

    PrimaryStructure.defaultState({
      update: function() {
        return function() {
          return this.updateBuildQueue();
        };
      },
      messages: {
        depositMinerals: function(minAmt) {
          this.mineralAmt += minAmt;
          return this.say('mineralsCollected', this.mineralAmt);
        },
        buildUnit: function(unitName) {
          var u;
          u = SCSim.data.units[unitName];
          return this.buildQueue.push({
            startTime: this.time.sec,
            buildTime: u.buildTime,
            unitName: unitName
          });
        },
        doneBuildUnit: function(unitName) {
          var unit;
          unit = this.sim.createActor(SCSim.data.units[unitName].actor());
          unit.say('gatherFromMinPatch', this.rallyResource);
          this.buildQueue = this.buildQueue.slice(1);
          if (this.buildQueue.length > 0) {
            return this.buildQueue[0].startTime = this.time.sec;
          }
        }
      }
    });

    return PrimaryStructure;

  })(SCSim.Actor);

  SCSim.MinPatch = (function(_super) {

    __extends(MinPatch, _super);

    MinPatch.name = 'MinPatch';

    function MinPatch(base, startingAmt) {
      if (startingAmt == null) {
        startingAmt = 100;
      }
      this.amt = startingAmt;
      this.base = base;
      this.workers = [];
      this.workerMining = null;
      this.targetedBy = 0;
      this.workerOverlapThreshold = SCSim.config.workerOverlapThreshold;
      MinPatch.__super__.constructor.call(this);
    }

    MinPatch.prototype.getClosestAvailableResource = function() {
      var m, sortedMins, _i, _len;
      sortedMins = _(this.base.mins).sortBy(function(m) {
        return m.targetedBy;
      });
      for (_i = 0, _len = sortedMins.length; _i < _len; _i++) {
        m = sortedMins[_i];
        if (m !== this) {
          return m;
        }
      }
    };

    MinPatch.prototype.isAvailable = function() {
      return this.workerMining === null;
    };

    MinPatch.prototype.isAvailableSoon = function(wrkr) {
      return this.workerMiningTimeDone - this.time.sec < this.workerOverlapThreshold;
    };

    MinPatch.defaultState({
      update: MinPatch.noopUpdate,
      messages: {
        workerArrived: function(wrkr) {
          return this.workers.push(wrkr);
        },
        mineralsHarvested: function(amtHarvested) {
          return this.amt -= amtHarvested;
        },
        workerStartedMining: function(wrkr, timeMiningDone) {
          this.workerMiningTimeDone = timeMiningDone;
          return this.workerMining = wrkr;
        },
        workerFinishedMiningXminerals: function(wrkr, amtMined) {
          this.workerMining = null;
          this.workers = _(this.workers).rest();
          return this.amt -= amtMined;
        },
        workerCanceledHarvest: function(wrkr) {
          this.workers = _(this.workers).without(wrkr);
          if (this.workerMining === wrkr) {
            return this.workerMining = null;
          }
        },
        targetedByHarvester: function() {
          return this.targetedBy += 1;
        },
        untargetedByHarvester: function() {
          return this.targetedBy -= 1;
        }
      }
    });

    return MinPatch;

  })(SCSim.Actor);

  SCSim.Harvester = (function(_super) {

    __extends(Harvester, _super);

    Harvester.name = 'Harvester';

    function Harvester() {
      this.t_toBase = 2;
      this.t_toPatch = 2;
      this.t_mine = 1.5;
      this.targetResource;
      this.collectAmt = 5;
      Harvester.__super__.constructor.call(this, 'idle');
    }

    Harvester.state("idle", {
      update: Harvester.noopUpdate,
      messages: {
        gatherMinerals: function(minPatch) {
          return this.say('gatherFromMinPatch', minPatch);
        },
        gatherFromMinPatch: function(minPatch) {
          this.targetResource = minPatch;
          this.targetResource.say('targetedByHarvester');
          return this.switchStateTo('approachResource');
        }
      }
    });

    Harvester.state("approachResource", {
      update: function() {
        return this.sayAfter(this.t_toBase, 'arrivedAtMinPatch');
      },
      messages: {
        arrivedAtMinPatch: function() {
          this.targetResource.say('workerArrived', this);
          return this.switchStateTo('waitAtResource');
        }
      }
    });

    Harvester.state("waitAtResource", {
      update: function() {
        return function() {
          if (this.targetResource.isAvailable()) {
            return this.switchStateTo('harvest');
          }
        };
      },
      enterState: function() {
        var nextResource;
        if (this.targetResource.isAvailable()) {
          return this.switchStateTo('harvest');
        } else if (!this.targetResource.isAvailableSoon()) {
          nextResource = this.targetResource.getClosestAvailableResource();
          if (nextResource) {
            return this.say('changeTargetResource', nextResource);
          }
        }
      },
      messages: {
        changeTargetResource: function(newResource) {
          this.targetResource.say('workerCanceledHarvest', this);
          this.targetResource.say('untargetedByHarvester');
          this.targetResource = newResource;
          this.targetResource.say('targetedByHarvester');
          return this.switchStateTo('approachResource');
        }
      }
    });

    Harvester.state("harvest", {
      update: function() {
        return this.sayAfter(this.t_mine, 'finishedMining');
      },
      enterState: function() {
        return this.targetResource.say('workerStartedMining', this, this.time.sec + this.t_mine);
      },
      messages: {
        finishedMining: function() {
          this.targetResource.say('workerFinishedMiningXminerals', this, this.collectAmt);
          return this.switchStateTo('approachDropOff', this.targetResource.base);
        }
      }
    });

    Harvester.state("approachDropOff", {
      update: function(base) {
        return this.sayAfter(this.t_toBase, 'arrivedAtBase', base);
      },
      messages: {
        arrivedAtBase: function(base) {
          return this.switchStateTo('dropOff', base);
        }
      }
    });

    Harvester.state("dropOff", {
      update: Harvester.noopUpdate,
      enterState: function(base) {
        base.say('depositMinerals', this.collectAmt);
        return this.say('finishedDropOff', base);
      },
      messages: {
        finishedDropOff: function(base) {
          return this.switchStateTo('approachResource');
        }
      }
    });

    return Harvester;

  })(SCSim.Actor);

}).call(this);
