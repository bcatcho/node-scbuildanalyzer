// Generated by CoffeeScript 1.3.1
(function() {
  var SCSim, addSeries, options, root, runSim, series, _ref;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  SCSim = root.SCSim;

  runSim = function(harvesterCount, simLength) {
    var base, d, dataChunkTime, dataFirstPass, e, i, logs, n, perChunkToPerMin, results, sim, simRun, simTickLength, tickToDate, time, _i, _j, _k, _len, _ref,
      _this = this;
    if (simLength == null) {
      simLength = 600;
    }
    simTickLength = simLength / SCSim.config.secsPerTick;
    tickToDate = function(t) {
      return new Date(t * 1000);
    };
    logs = {
      mineralsCollected: []
    };
    simRun = new SCSim.SimRun;
    sim = simRun.sim;
    simRun.emitter.observe('mineralsCollected', function(e) {
      return logs.mineralsCollected.push([e.time.sec, e.args[0] / (e.time.sec / 60)]);
    });
    console.profile();
    base = sim.makeActor("nexus");
    sim.say('start');
    for (i = _i = 1; 1 <= harvesterCount ? _i <= harvesterCount : _i >= harvesterCount; i = 1 <= harvesterCount ? ++_i : --_i) {
      base.say("trainUnit", 'probe');
    }
    for (i = _j = 1; 1 <= simTickLength ? _j <= simTickLength : _j >= simTickLength; i = 1 <= simTickLength ? ++_j : --_j) {
      simRun.update();
    }
    console.profileEnd();
    results = {
      data: [],
      markings: []
    };
    dataChunkTime = 25.;
    dataFirstPass = [];
    _ref = logs.mineralsCollected;
    for (_k = 0, _len = _ref.length; _k < _len; _k++) {
      e = _ref[_k];
      time = Math.floor(e[0] / dataChunkTime);
      if (dataFirstPass[time] === void 0) {
        dataFirstPass[time] = {
          time: tickToDate(time * dataChunkTime),
          amt: 0
        };
      }
      dataFirstPass[time].amt += 5;
    }
    perChunkToPerMin = function(amt) {
      return amt * (60 / dataChunkTime);
    };
    results.data = (function() {
      var _results;
      _results = [];
      for (n in dataFirstPass) {
        d = dataFirstPass[n];
        _results.push([d.time, perChunkToPerMin(d.amt)]);
      }
      return _results;
    })();
    return results;
  };

  addSeries = function(series, options, harvesterCount) {
    var results;
    results = runSim(harvesterCount, 600);
    series.push({
      data: results.data,
      shadowSize: 0,
      lines: {
        lineWidth: 2
      }
    });
    options.grid.markings = options.grid.markings.concat(results.markings);
    return {
      series: series,
      options: options
    };
  };

  options = {
    grid: {
      borderWidth: 0,
      markings: []
    },
    xaxis: {
      mode: "time",
      timeformat: "%M:%S"
    }
  };

  series = [];

  _ref = addSeries(series, options, 14), series = _ref.series, options = _ref.options;

  $.plot($("#placeholder"), series, options);

}).call(this);
