// Generated by CoffeeScript 1.3.1
(function() {
  var Base, EconSim, MineralPatch, SimActor, SimEventLog, SimSingletons, SimTimer, Worker, common, root, _,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ = require('underscore');

  _.mixin({
    rot: function(arr, num) {
      if (num == null) {
        num = 1;
      }
      return this.rest(arr, num).concat(this.first(arr, num));
    },
    containsInstanceOf: function(collection, theType) {
      if (_(collection).isObject()) {
        collection = _(collection).values();
      }
      return _(collection).any(function(i) {
        return i instanceof theType;
      });
    }
  });

  SimSingletons = (function() {

    SimSingletons.name = 'SimSingletons';

    function SimSingletons() {}

    SimSingletons.dependency = {};

    SimSingletons.register = function(proto, instance) {
      this.dependency[proto.name] = instance != null ? instance : new proto;
      return this.dependency[proto.name];
    };

    SimSingletons.get = function(proto) {
      if (this.dependency[proto.name] === void 0) {
        console.error("dependency not found: " + proto.name);
      }
      return this.dependency[proto.name];
    };

    return SimSingletons;

  })();

  SimEventLog = (function() {

    SimEventLog.name = 'SimEventLog';

    function SimEventLog() {
      this.events = {};
      this.eventsToCollect = {};
    }

    SimEventLog.prototype.defaultFormatter = function(e) {
      return e;
    };

    SimEventLog.prototype.event = function(eventName, filter) {
      var _ref;
      return (_ref = this.events[eventName]) != null ? _ref : [];
    };

    SimEventLog.prototype.watchFor = function(eventNames) {
      var e, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
        e = eventNames[_i];
        this.eventsToCollect[e] = this.defaultFormatter;
        _results.push(this.events[e] = []);
      }
      return _results;
    };

    SimEventLog.prototype.fwatchFor = function(eventName, formatter) {
      var _base, _ref;
      this.eventsToCollect[eventName] = formatter != null ? formatter : this.defaultFormatter;
      return (_ref = (_base = this.events)[eventName]) != null ? _ref : _base[eventName] = [];
    };

    SimEventLog.prototype.log = function(e) {
      var formatter;
      formatter = this.eventsToCollect[e.eventName];
      if (formatter) {
        return this.events[e.eventName].push(formatter(e));
      }
    };

    SimEventLog.prototype.clear = function() {
      this.events = {};
      return this.watchFor(_(this.eventsToCollect).keys());
    };

    SimEventLog.prototype.eventOccurs = function(eventName, timeOut, condition) {
      if (!this.events[eventName]) {
        this.watchFor(eventName);
      }
      return this.event(eventName).length > 0 || timeOut < 0;
    };

    return SimEventLog;

  })();

  SimTimer = (function() {

    SimTimer.name = 'SimTimer';

    function SimTimer() {
      this.tick = 0;
      this.seconds = 0;
    }

    SimTimer.prototype.step = function(steps) {
      if (steps == null) {
        steps = 1;
      }
      this.tick += steps;
      return this.seconds += steps;
    };

    SimTimer.prototype.reset = function() {
      this.tick = 0;
      return this.seconds = 0;
    };

    return SimTimer;

  })();

  SimActor = (function() {

    SimActor.name = 'SimActor';

    function SimActor(defaultStateName) {
      if (defaultStateName == null) {
        defaultStateName = "default";
      }
      this.currentState;
      this.logger = SimSingletons.get(SimEventLog);
      this.time = SimSingletons.get(SimTimer);
      this.currentTransitions;
      this.switchStateTo(defaultStateName);
    }

    SimActor.prototype.switchStateTo = function(sn, a, b, c, d) {
      var _ref;
      this.stateName = sn;
      this.currentState = this["state_" + this.stateName].update.call(this, a, b, c, d);
      this.currentTransitions = this["state_" + this.stateName].messages;
      return (_ref = this["state_" + this.stateName].enterState) != null ? _ref.call(this, a, b, c, d) : void 0;
    };

    SimActor.prototype.say = function(msgName, a, b, c, d) {
      var _ref, _ref1;
      if ((_ref = this.logger) != null) {
        _ref.log({
          eventName: msgName,
          eventTime: this.time.tick,
          simId: this.simId,
          args: [a, b, c, d]
        });
      }
      return (_ref1 = this.currentTransitions[msgName]) != null ? _ref1.call(this, a, b, c, d) : void 0;
    };

    SimActor.prototype.update = function(t) {
      return this.currentState(t);
    };

    SimActor.state = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.prototype["state_" + args[0]] = args[1];
    };

    SimActor.defaultState = function(obj) {
      return this.prototype["state_default"] = obj;
    };

    SimActor.prototype.isExpired = function(t) {
      return t <= 0;
    };

    SimActor.prototype.sayAfter = function(timeSpan, a, b, c, d) {
      return function(t) {
        if (this.isExpired(timeSpan--)) {
          return this.say(a, b, c, d);
        }
      };
    };

    SimActor.noopUpdate = function() {
      return function() {};
    };

    return SimActor;

  })();

  root.SimSingletons = SimSingletons;

  root.SimEventLog = SimEventLog;

  root.SimActor = SimActor;

  root.SimTimer = SimTimer;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  _ = require('underscore');

  common = require('./sim.common.coffee');

  EconSim = (function(_super) {

    __extends(EconSim, _super);

    EconSim.name = 'EconSim';

    function EconSim() {
      this.subActors = {};
      EconSim.__super__.constructor.call(this);
    }

    EconSim.prototype.createActor = function(actr, a, b, c, d) {
      var instance;
      instance = new actr(a, b, c, d);
      instance.sim = this;
      instance.simId = _.uniqueId();
      this.subActors[instance.simId] = instance;
      if (typeof instance.instantiate === "function") {
        instance.instantiate();
      }
      return instance;
    };

    EconSim.prototype.getActor = function(simId) {
      return this.subActors[simId];
    };

    EconSim.defaultState({
      update: EconSim.noopUpdate,
      messages: {
        start: function() {
          return this.switchStateTo('running');
        }
      }
    });

    EconSim.state("running", {
      update: function() {
        return function(t) {
          var actr, _results;
          this.time.step();
          _results = [];
          for (actr in this.subActors) {
            _results.push(this.subActors[actr].update(this.time.tick));
          }
          return _results;
        };
      }
    });

    return EconSim;

  })(common.SimActor);

  Base = (function(_super) {

    __extends(Base, _super);

    Base.name = 'Base';

    function Base() {
      this.mineralAmt = 0;
      this.mins = [];
      this.rallyResource = this.mins[0];
      this.t_buildWorker = 17;
      this.buildQueue = [];
      Base.__super__.constructor.call(this);
    }

    Base.prototype.instantiate = function() {
      var i;
      this.mins = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; _i <= 8; i = ++_i) {
          _results.push(this.sim.createActor(MineralPatch, this));
        }
        return _results;
      }).call(this);
      return this.rallyResource = this.mins[0];
    };

    Base.prototype.updateBuildQueue = function() {
      var thing, thingBuilding;
      if (this.buildQueue.length > 0) {
        thingBuilding = this.buildQueue[0];
        if (this.isExpired(this.t_buildWorker - (this.time.tick - thingBuilding.startTime))) {
          thing = this.sim.createActor(thingBuilding.thing);
          thing.say('gatherFromMinPatch', this.rallyResource);
          this.buildQueue = this.buildQueue.slice(1);
          if (this.buildQueue.length > 0) {
            return this.buildQueue[0].startTime = this.time.tick;
          }
        }
      }
    };

    Base.prototype.getMostAvailableMinPatch = function() {
      this.mins = _.sortBy(this.mins, function(m) {
        return m.workers.length;
      });
      return this.mins[0];
    };

    Base.defaultState({
      update: function() {
        return function() {
          return this.updateBuildQueue();
        };
      },
      messages: {
        depositMinerals: function(minAmt) {
          return this.mineralAmt += minAmt;
        },
        buildNewWorker: function() {
          return this.buildQueue.push({
            startTime: this.time.tick,
            thing: Worker
          });
        }
      }
    });

    return Base;

  })(common.SimActor);

  MineralPatch = (function(_super) {

    __extends(MineralPatch, _super);

    MineralPatch.name = 'MineralPatch';

    function MineralPatch(base, startingAmt) {
      if (startingAmt == null) {
        startingAmt = 100;
      }
      this.amt = startingAmt;
      this.base = base;
      this.workers = [];
      this.workerMining = null;
      MineralPatch.__super__.constructor.call(this);
    }

    MineralPatch.prototype.nearbyAvailableResource = function() {
      var m, mins, _i, _len;
      mins = this.base.mins;
      for (_i = 0, _len = mins.length; _i < _len; _i++) {
        m = mins[_i];
        if (m !== this) {
          if (m.isAvailable()) {
            return m;
          }
        }
      }
    };

    MineralPatch.prototype.isAvailable = function() {
      return this.workerMining === null;
    };

    MineralPatch.defaultState({
      update: MineralPatch.noopUpdate,
      messages: {
        workerArrived: function(wrkr) {
          return this.workers.push(wrkr);
        },
        mineralsHarvested: function(amtHarvested) {
          return this.amt -= amtHarvested;
        },
        workerStartedMining: function(wrkr) {
          return this.workerMining = wrkr;
        },
        workerFinishedMiningXminerals: function(wrkr, amtMined) {
          this.workerMining = null;
          this.workers = _(this.workers).rest();
          return this.amt -= amtMined;
        },
        workerCanceledHarvest: function(wrkr) {
          this.workers = _(this.workers).without(wrkr);
          if (this.workerMining === wrkr) {
            return this.workerMining = null;
          }
        }
      }
    });

    return MineralPatch;

  })(common.SimActor);

  Worker = (function(_super) {

    __extends(Worker, _super);

    Worker.name = 'Worker';

    function Worker() {
      this.t_toBase = 3;
      this.t_toPatch = 3;
      this.t_mine = 4;
      this.targetResource;
      this.collectAmt = 5;
      Worker.__super__.constructor.call(this, 'idle');
    }

    Worker.state("idle", {
      update: Worker.noopUpdate,
      messages: {
        gatherMinerals: function(minPatch) {
          return this.say('gatherFromMinPatch', minPatch);
        },
        gatherFromMinPatch: function(minPatch) {
          this.targetResource = minPatch;
          return this.switchStateTo('approachResource');
        }
      }
    });

    Worker.state("approachResource", {
      update: function() {
        return this.sayAfter(this.t_toPatch, 'arrivedAtMinPatch');
      },
      messages: {
        arrivedAtMinPatch: function() {
          this.targetResource.say('workerArrived', this);
          return this.switchStateTo('waitAtResource');
        }
      }
    });

    Worker.state("waitAtResource", {
      update: function() {
        return function() {
          if (this.targetResource.isAvailable()) {
            return this.switchStateTo('harvest');
          }
        };
      },
      enterState: function() {
        var betterResource;
        if (this.targetResource.isAvailable()) {
          return this.switchStateTo('harvest');
        } else {
          betterResource = this.targetResource.nearbyAvailableResource();
          if (betterResource) {
            return this.say('changeTargetResource', betterResource);
          }
        }
      },
      messages: {
        changeTargetResource: function(newTargetResource) {
          this.targetResource.say('workerCanceledHarvest', this);
          this.targetResource = newTargetResource;
          return this.switchStateTo('approachResource');
        }
      }
    });

    Worker.state("harvest", {
      update: function() {
        return this.sayAfter(this.t_mine, 'finishedMining');
      },
      enterState: function() {
        return this.targetResource.say('workerStartedMining', this);
      },
      messages: {
        finishedMining: function() {
          this.targetResource.say('workerFinishedMiningXminerals', this, this.collectAmt);
          return this.switchStateTo('approachDropOff', this.targetResource.base);
        }
      }
    });

    Worker.state("approachDropOff", {
      update: function(base) {
        return this.sayAfter(this.t_toBase, 'arrivedAtBase', base);
      },
      messages: {
        arrivedAtBase: function(base) {
          return this.switchStateTo('dropOff', base);
        }
      }
    });

    Worker.state("dropOff", {
      update: Worker.noopUpdate,
      enterState: function(base) {
        base.say('depositMinerals', this.collectAmt);
        return this.say('finishedDropOff', base);
      },
      messages: {
        finishedDropOff: function(base) {
          return this.switchStateTo('approachResource');
        }
      }
    });

    return Worker;

  })(common.SimActor);

  root.Worker = Worker;

  root.EconSim = EconSim;

  root.Base = Base;

  root.MineralPatch = MineralPatch;

}).call(this);
